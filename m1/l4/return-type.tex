\subsection{Overloading and return type}

\begin{frame}[t,fragile]{Specifying return type}
\begin{itemize}
  \item An overload can be used to allow specifying the return type.

\begin{block}{Deduced versus specified return type}
\begin{lstlisting}
template <arithmetic T>
T squares_sum(T x, T y) {
  return x * x + y * y;
}

template <arithmetic R, arithmetic T>
R squares_sum(T x, T y) {
  return x * x + y * y;
}
\end{lstlisting}
\end{block}

\end{itemize}
\end{frame}


\begin{frame}[t,fragile]{Implicit versus explicit return type}
\begin{itemize}

  \item Only one overload must be a better match.

\begin{block}{Invoking with explicit return type}
\begin{lstlisting}
void f() {
  auto r1 = squares_sum(2,3); // squares_sum<int>(int,int)

  auto r2 = squares_sum<double>(2,3); // squares_sum<double,int>(int, int)

  auto r3 = squares_sum<int>(2,3); // Ambiguous
    // squares_sum<int>(int,int)
    // squares_sum<int,int>(int,int)
}
\end{lstlisting}
\end{block}

\end{itemize}
\end{frame}

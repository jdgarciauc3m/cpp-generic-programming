\subsection{Unconstrained generic functions}

\begin{frame}[t,fragile]{A generic function with no constraints}
\begin{itemize}
  \item A generic function may be defined without constraints on
        a type.
\end{itemize}

\begin{block}{Unconstrained generic \textbf{square} function}
\begin{lstlisting}
void print_square(auto x) {
  std::cout << std::format("{}^2 = {}\n", x, x*x);
}
\end{lstlisting}
\end{block}

\begin{itemize}
  \item The keyword \cppkey{auto} without a preceding concept name
        stands for the \textmark{universal concept} (any type).
    \begin{itemize}
      \item Function can be called with a value from \textgood{any type}.
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Template notation}
\begin{itemize}
  \item A classic \textemph{template notation} is equivalent.
\end{itemize}

\begin{block}{Unconstrained generic \textbf{square} function with template notation}
\begin{lstlisting}
template <typename T>
void print_square(T x) {
  std::cout << std::format("{}^2 = {}\n", x, x*x);
}
\end{lstlisting}
\end{block}
\end{frame}

\begin{frame}[t,fragile]{Template notation and constraints}

\begin{itemize}
  \item A template parameter may be constrained to satisfy a \emph{concept}:
    \begin{itemize}
      \item The requirement is expressed in the \cppkey{requires} clause.
    \end{itemize}
\end{itemize}

\begin{block}{Constrained generic \textbf{square} function with template notation}
\begin{lstlisting}
template <typename T>
  requires std::integral<T>
void print_square(T x) {
  std::cout << std::format("{}^2 = {}\n", x, x*x);
}
\end{lstlisting}
\end{block}

\end{frame}

\subsection{Basic ranges and views}

\begin{frame}[t,fragile]{Ranges}
\begin{itemize}
  \item A \textgood{range} is any type \cppid{r} that allows \textmark{iteration} by
        providing:
    \begin{itemize}
      \item A iterator to the beginning with \cppid{std::ranges::begin(r)}.
      \item A sentinel to the end with \cppid{std::ranges::end(r)}.
    \end{itemize}

  \mode<presentation>{\vfill\pause}
  \item \textemph{Observations}:
    \begin{itemize}
      \item Any type with member functions \cppid{begin()} and \cppid{end()} is a
            range.
\begin{lstlisting}
std::vector v{1,2,3}; // v is a range
\end{lstlisting}

      \pause
      \item Algorithms are overloaded to take a \textgood{range} instead of two
            iterators.
\begin{lstlisting}
std::ranges::sort(v); // Equivalent to std::sort(v.begin(), v.end();
\end{lstlisting}

      \pause
      \item Any range can be used in a range-based for loop.
\begin{lstlisting}
for (auto x : v) {
  std::print("{}",x);
\end{lstlisting}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Views}
\begin{itemize}
  \item A \textgood{view} is a range that is very cheap to create, copy or move.
    \begin{itemize}
      \item The range must be movable.
      \item A range that derives from \cppid{std::view\_base} is a view.
      \item A range that derives from \cppid{std::view\_iterface<U>} is a view.
    \end{itemize}

  \mode<presentation>{\vfill\pause}
  \item \textemph{Observations}:
    \begin{itemize}

      \item Views are easily generated by \textmark{range adaptors}:
\begin{lstlisting}
std::vector v{1,2,3,4,5};
for (auto x : std::views::drop(v,3)) { // Discard first 3 elements
  std::print("{} ", x); // Prints "4 5 "
}
\end{lstlisting}

      \item Ranges and views can be \textmark{pipelined}.
\begin{lstlisting}
std::vector v{1,2,3,4,5};
for (auto x : v | std::views::drop(3)) { // Discard first 3 elements
  std::print("{} ", x); // Prints "4 5 "
}
\end{lstlisting}

    \end{itemize}


\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Semantic requirements of ranges}
\begin{itemize}
  \item \textmark{Semantics} for a range expression \cppid{rng} of type \cppid{R}:
    \begin{itemize}
      \item \cppid{std::ranges::begin(rng)} and \cppid{std::ranges::end(rng)}
            have amortized constant time.
      \item \cppid{std::ranges::begin(rng)} and \cppid{std::ranges::end(rng)} 
            do not alter \cppid{rng} in manner observable to equality-preserving
            expressions.
      \item If the type of \cppid{std::ranges::begin(rng)} is a
            fordward-iterator, the multipass algorithms are supported.
    \end{itemize}

  \mode<presentation>{\vfill\pause}
  \item \textmark{Typical implementation}:
    \begin{itemize}
      \item A member function \cppid{begin()} with a return type that
            satisfies \cppid{input\_or\_output\_iterator}.
      \item A member function \cppid{end()} with a return type that
            satisfies \cppid{sentinel\_for<I>}.
        \begin{itemize}
          \item \cppid{I} is the return type of \cppid{begin()}.
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Semantic requirements of views}
\begin{itemize}
  \item \textmark{Semantics}:
    \begin{itemize}
      \item Move construction has constant time complexity.
      \item A moved-from view has constant time complexity for destruction.
      \item Is not copy-contructible or copy-construction has constant-time
            compelxity.
      \item Is not copyable or copy-assignment has no more time complexity
            than destruction followed by copy construction.
    \end{itemize}

  \mode<presentation>{\vfill\pause}
  \item \textmark{Example}:
    \begin{itemize}
      \item A view from a pair of iterators $\rightarrow$
            \cppid{std::ranges::subrange(i1,i2)}
\begin{lstlisting}
std::vector v{1,2,3,4,5,6,7,8,9,10}
auto i1 = std::ranges::find(v,3);
auto i7 = std::ranges::find(v,7);
for (auto x : std::ranges::subrange(i1,i2) {
  std::print("{} ",x); // prints "3 4 5 6 "
}
\end{lstlisting}

    \end{itemize}
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Pipelining and views}
\begin{itemize}
  \item Multiple \textmark{range adaptors} can be combined in a
        \textmark{pipeline}.
\begin{lstlisting}
auto nums = v 
    | std::views::filter([](auto x) { return x>=1 and x<=100; }) 
    | std::views::transform([](auto x) { return 1.0/x; }
    | std::views::take(5);
for (auto x : nums) { std::print("{} ", x); }
\end{lstlisting}

  \mode<presentation>{\vfill\pause}
  \item Equivalent to a nested call chain:
\begin{lstlisting}
auto nums = std::views::take(
  std::views::transform(
    std::filter(
      v,
      [](auto x) { return x>=1 and x<=100; }),      
    [](auto x) { return 1.0/x; }),
  5);
\end{lstlisting}
\end{itemize}
\end{frame}
